---
title: "汎用的原則"
---
## 参考元:TakutoWada先生のツイート

<https://twitter.com/t_wada/status/904916106153828352?s=20&t=ICMQL4rRrUbH6e0phPwnbw>

## 原則

- **コードには How (どのように):**
  - **理由:** コードはプログラムが「どのように」動作するかを具体的に示すものです。実装の詳細、アルゴリズム、ロジックの流れがここで表現されます。コード自体がその機能をどのように実現しているかを明確にすることで、他の開発者がコードの意図と機能を理解しやすくなります。

- **テストコードには What (何を):**
  - **理由:** テストコードはプログラムが「何を」するべきか、つまり要件や仕様を満たしているかを検証します。これにより、コードが期待通りに動作することを保証し、将来の変更によって機能が壊れないようにします。テストは機能や振る舞いを中心に構築され、プログラムの目的を明確にします。

- **コミットログには Why (なぜ):**
  - **理由:** コミットログは変更が「なぜ」行われたのかを説明します。これはプロジェクトの履歴の一部として重要で、他の開発者や将来の自分が変更の背景や目的を理解するのに役立ちます。特に複雑な修正や重要な機能追加の際には、その理由を文書化することが重要です。

- **コードコメントには Why not (なぜそうしないのか):**
  - **理由:** コードコメントは「なぜそうしないのか」、つまり特定の実装が選ばれなかった理由や、特定の問題に対するアプローチの選択肢を説明します。これにより、コードの読者は開発者が特定の方法を選んだ背景や、他の方法が採用されなかった理由を理解できます。これは特に、直感に反するか複雑なコードの部分で有用です。

## 例題一覧

1. **FizzBuzz:** 1から100までの数を順に出力するが、3で割り切れる数の場合は「Fizz」、5で割り切れる数の場合は「Buzz」、3と5の両方で割り切れる数の場合は「FizzBuzz」と出力し、それ以外の数の場合はその数を出力する。
2. **階乗の計算:** 与えられた数値の階乗（n!）を計算する。階乗は、1からその数までの全ての整数の積です。
3. **フィボナッチ数列:** フィボナッチ数列の最初のn個の数を生成する。フィボナッチ数列では、最初の2つの数は0と1で、次の数は前の2つの数の和となります。
4. **素数の判定:** 与えられた数が素数（1と自分自身以外に約数を持たない数）かどうかを判定する。
5. **パリンドローム判定:** 与えられた文字列がパリンドローム（前から読んでも後ろから読んでも同じになる文字列）かどうかを判定する。
6. **最大公約数と最小公倍数:** 2つの数の最大公約数（GCD）と最小公倍数（LCM）を計算する。
7. **アナグラム判定:** 2つの文字列がアナグラム（文字を並び替えることで互いに変換できる関係）かどうかを判定する。
8. **バブルソート:** バブルソートアルゴリズムを使用して、配列やリストの要素を並び替える。
9. **二分探索:** ソートされた配列やリストから特定の要素を二分探索アルゴリズムを使用して探す。
